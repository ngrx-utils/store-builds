{"version":3,"file":"store.js","sources":["../../../modules/store/src/pluck.ts","../../../modules/store/src/select.ts","../../../modules/store/src/module.ts"],"sourcesContent":["import { Selector, select } from '@ngrx/store';\nimport { NgrxSelect } from './module';\n\n/**\n * Provide an utility for select a piece of state from Root State.\n * Support shorthand syntax with 'dot' split property name and leave it empty\n * will use the component property name.\n * @example\n * export class MyComponent {\n *   @Pluck() prop1: Observable<any>\n *   @Pluck('feature.prop2') prop2: Observable<any>\n *   @Pluck('feature', 'prop3') prop3: Observable<any>\n * }\n */\nexport function Pluck<A = any, B = any>(path?: string, ...paths: string[]) {\n  return function(target: any, name: string) {\n    let fn: Selector<A, B>;\n\n    if (!path) {\n      path = name;\n    }\n\n    if (typeof path !== 'string') {\n      throw new TypeError(\n        `Unexpected type '${typeof path}' in select operator,` + ` expected 'string'`\n      );\n    }\n\n    fn = getPropFactory(paths.length ? [path, ...paths] : path.split('.'));\n\n    /**\n     * Get property descriptor for more precise define object property\n     */\n    const descriptor = Object.getOwnPropertyDescriptor(target, name);\n\n    if (delete target[name]) {\n      Object.defineProperty(target, name, {\n        get() {\n          const source$ = NgrxSelect.store;\n\n          if (!source$) {\n            throw new Error('NgrxSelect not connected to store!');\n          }\n\n          return source$.pipe(select(fn));\n        },\n        ...descriptor\n      });\n    }\n  };\n}\n\nfunction getPropFactory(paths: string[]) {\n  return (state: { [prop: string]: any }) =>\n    paths.reduce((prev, cur) => {\n      return prev && prev[cur];\n    }, state);\n}\n","import { select, Selector } from '@ngrx/store';\nimport { OperatorFunction } from 'rxjs/interfaces';\n\nimport { NgrxSelect } from './module';\n\nexport function Select<A, B>(mapFn: Selector<A, B>): (target: any, name: string) => void;\nexport function Select<A, B, C>(\n  mapFn: Selector<A, B>,\n  op1: OperatorFunction<B, C>\n): (target: any, name: string) => void;\nexport function Select<A, B, C, D>(\n  mapFn: Selector<A, B>,\n  op1: OperatorFunction<B, C>,\n  op2: OperatorFunction<C, D>\n): (target: any, name: string) => void;\nexport function Select<A, B, C, D, E>(\n  mapFn: (state: A) => B,\n  op1: OperatorFunction<B, C>,\n  op2: OperatorFunction<C, D>,\n  op3: OperatorFunction<D, E>\n): (target: any, name: string) => void;\nexport function Select<A, B, C, D, E, F>(\n  mapFn: Selector<A, B>,\n  op1: OperatorFunction<B, C>,\n  op2: OperatorFunction<C, D>,\n  op3: OperatorFunction<D, E>,\n  op4: OperatorFunction<E, F>\n): (target: any, name: string) => void;\nexport function Select<A, B, C, D, E, F, G>(\n  mapFn: Selector<A, B>,\n  op1: OperatorFunction<B, C>,\n  op2: OperatorFunction<C, D>,\n  op3: OperatorFunction<D, E>,\n  op4: OperatorFunction<E, F>,\n  op5: OperatorFunction<F, G>\n): (target: any, name: string) => void;\nexport function Select<A, B, C, D, E, F, G, H>(\n  mapFn: Selector<A, B>,\n  op1: OperatorFunction<B, C>,\n  op2: OperatorFunction<C, D>,\n  op3: OperatorFunction<D, E>,\n  op4: OperatorFunction<E, F>,\n  op5: OperatorFunction<F, G>,\n  op6: OperatorFunction<G, H>\n): (target: any, name: string) => void;\nexport function Select<A, B, C, D, E, F, G, H, I>(\n  mapFn: Selector<A, B>,\n  op1: OperatorFunction<B, C>,\n  op2: OperatorFunction<C, D>,\n  op3: OperatorFunction<D, E>,\n  op4: OperatorFunction<E, F>,\n  op5: OperatorFunction<F, G>,\n  op6: OperatorFunction<G, H>,\n  op7: OperatorFunction<H, I>\n): (target: any, name: string) => void;\nexport function Select<A, B, C, D, E, F, G, H, I, J>(\n  mapFn: Selector<A, B>,\n  op1: OperatorFunction<B, C>,\n  op2: OperatorFunction<C, D>,\n  op3: OperatorFunction<D, E>,\n  op4: OperatorFunction<E, F>,\n  op5: OperatorFunction<F, G>,\n  op6: OperatorFunction<G, H>,\n  op7: OperatorFunction<H, I>,\n  op8: OperatorFunction<I, J>\n): (target: any, name: string) => void;\n\n/**\n * Select decorator act like pipe operator of Observable\n * except the first parameter is a selector to select a piece\n * of state from @ngrx/store and you won't be able to subscribe to it\n * @example\n * export class MyComponent {\n *   @Select(fromStore.getAuth, take(1))\n *   isAuth: Observable<boolean>\n * }\n */\nexport function Select<A, B>(\n  mapFn: ((state: A) => B),\n  ...operations: OperatorFunction<any, any>[]\n) {\n  return function(target: any, name: string): void {\n    if (typeof mapFn !== 'function') {\n      throw new TypeError(\n        `Unexpected type '${typeof mapFn}' in select operator,` + ` expected 'function'`\n      );\n    }\n\n    /**\n     * Get property descriptor for more precise define object property\n     */\n    const descriptor = Object.getOwnPropertyDescriptor(target, name);\n\n    if (delete target[name]) {\n      Object.defineProperty(target, name, {\n        get() {\n          const source$ = NgrxSelect.store;\n\n          if (!source$) {\n            throw new Error('NgrxSelect not connected to store!');\n          }\n\n          return source$.pipe(select(mapFn), ...operations);\n        },\n        ...descriptor\n      });\n    }\n  };\n}\n","import { NgModule, Injectable } from '@angular/core';\nimport { Store } from '@ngrx/store';\n\n@Injectable()\nexport class NgrxSelect {\n  /**\n   * @internal\n   */\n  static store: Store<any> | undefined = undefined;\n\n  connect(store: Store<any>) {\n    NgrxSelect.store = store;\n  }\n}\n\n@NgModule({\n  providers: [NgrxSelect]\n})\nexport class NgrxUtilsModule {}\n"],"names":[],"mappings":"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"}