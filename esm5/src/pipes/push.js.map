{
  "version": 3,
  "file": "push.js",
  "sources": [
    "ng://@ngrx-utils/store/projects/store/src/pipes/push.ts"
  ],
  "sourcesContent": [
    "import {\n  ChangeDetectorRef,\n  EventEmitter,\n  NgModule,\n  OnDestroy,\n  Pipe,\n  PipeTransform,\n  WrappedValue,\n  ɵisObservable as isObservable,\n  ɵisPromise as isPromise\n} from '@angular/core';\nimport { Observable, SubscriptionLike } from 'rxjs';\nimport { Type, ɵstringify as stringify } from '@angular/core';\n\nexport function invalidPipeArgumentError(type: Type<any>, value: Object) {\n  return Error(`InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);\n}\n\ninterface SubscriptionStrategy {\n  createSubscription(\n    async: Observable<any> | Promise<any>,\n    updateLatestValue: any\n  ): SubscriptionLike | Promise<any>;\n  dispose(subscription: SubscriptionLike | Promise<any>): void;\n  onDestroy(subscription: SubscriptionLike | Promise<any>): void;\n}\n\nclass ObservableStrategy implements SubscriptionStrategy {\n  createSubscription(async: Observable<any>, updateLatestValue: any): SubscriptionLike {\n    return async.subscribe({\n      next: updateLatestValue,\n      error: (e: any) => {\n        throw e;\n      }\n    });\n  }\n\n  dispose(subscription: SubscriptionLike): void {\n    subscription.unsubscribe();\n  }\n\n  onDestroy(subscription: SubscriptionLike): void {\n    subscription.unsubscribe();\n  }\n}\n\nclass PromiseStrategy implements SubscriptionStrategy {\n  createSubscription(async: Promise<any>, updateLatestValue: (v: any) => any): Promise<any> {\n    return async.then(updateLatestValue, e => {\n      throw e;\n    });\n  }\n\n  dispose(subscription: Promise<any>): void {}\n\n  onDestroy(subscription: Promise<any>): void {}\n}\n\nconst _promiseStrategy = new PromiseStrategy();\nconst _observableStrategy = new ObservableStrategy();\n\n/**\n * @ngModule PushPipeModule\n * @description\n *\n * Unwraps a value from an asynchronous primitive.\n *\n * The `push` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has\n * emitted. When a new value is emitted, the `push` pipe will run change detection and it works\n * even when `zone` has been disabled. When the component gets destroyed,\n * the `push` pipe unsubscribes automatically to avoid potential memory leaks.\n *\n */\n@Pipe({ name: 'push', pure: false })\nexport class PushPipe implements PipeTransform, OnDestroy {\n  private _latestValue: any = null;\n  private _latestReturnedValue: any = null;\n\n  private _subscription: SubscriptionLike | Promise<any> | null = null;\n  private _obj: Observable<any> | Promise<any> | EventEmitter<any> | null = null;\n  private _strategy: SubscriptionStrategy = null!;\n\n  constructor(private _ref: ChangeDetectorRef) {}\n\n  transform<T>(obj: null): null;\n  transform<T>(obj: undefined): undefined;\n  transform<T>(obj: Observable<T> | Promise<T> | null | undefined): T | null;\n  transform(obj: Observable<any> | Promise<any> | null | undefined): any {\n    if (this._obj === null) {\n      if (obj != null) {\n        this._subscribe(obj);\n      }\n      this._latestReturnedValue = this._latestValue;\n      return this._latestValue;\n    }\n\n    if (obj !== this._obj) {\n      this._dispose();\n      return this.transform(obj as any);\n    }\n\n    if (this._latestValue === this._latestReturnedValue) {\n      return this._latestReturnedValue;\n    }\n\n    this._latestReturnedValue = this._latestValue;\n    return WrappedValue.wrap(this._latestValue);\n  }\n\n  ngOnDestroy() {\n    if (this._subscription !== null) {\n      this._dispose();\n    }\n  }\n\n  private _subscribe(obj: Observable<any> | Promise<any> | EventEmitter<any>): void {\n    this._obj = obj;\n    this._strategy = this._selectStrategy(obj);\n    this._subscription = this._strategy.createSubscription(obj, (value: Object) =>\n      this._updateLatestValue(obj, value)\n    );\n  }\n\n  private _dispose(): void {\n    this._strategy.dispose(this._subscription!);\n    this._latestValue = null;\n    this._latestReturnedValue = null;\n    this._subscription = null;\n    this._obj = null;\n  }\n\n  private _selectStrategy(obj: Observable<any> | Promise<any> | EventEmitter<any>): any {\n    if (isPromise(obj)) {\n      return _promiseStrategy;\n    }\n\n    if (isObservable(obj)) {\n      return _observableStrategy;\n    }\n\n    throw invalidPipeArgumentError(PushPipe, obj);\n  }\n\n  private _updateLatestValue(async: any, value: Object): void {\n    if (async === this._obj) {\n      this._latestValue = value;\n      this._ref.detectChanges();\n    }\n  }\n}\n\n@NgModule({\n  exports: [PushPipe],\n  declarations: [PushPipe]\n})\nexport class PushPipeModule {}\n"
  ],
  "names": [],
  "mappings": "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"
}
